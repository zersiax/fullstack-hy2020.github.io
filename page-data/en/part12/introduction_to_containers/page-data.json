{"componentChunkName":"component---src-templates-content-template-js","path":"/en/part12/introduction_to_containers","result":{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>Software development includes the whole lifecycle from envisioning the software to programming and to releasing the software to the end-users and even maintaining it. This part will introduce containers, a modern tool utilized in the latter parts of the software lifecycle.</p>\n<p>Containers encapsulate your application into a single package. This package will then include all of the dependencies with the application. As a result, each container can run isolated from the other containers.</p>\n<p>Containers prevent the application inside from accessing files and resources of the device. Developers can give the contained applications permission to access files and specify available resources. More accurately, containers are OS-level virtualization. The easiest-to-compare technology is a virtual machine (VM). VMs are used to run multiple operating systems on a single physical machine. They have to run the whole operating system, whereas a container runs the software using the host operating system. The resulting difference between VMs and containers is that there is hardly any overhead when running containers; they only need to run a single process.</p>\n<p>As containers are relatively lightweight, at least compared to virtual machines, they can be quick to scale. And as they isolate the software running inside, it enables the software to run identically almost anywhere. As such, they are the go-to option in any cloud environment or application with more than a handful of users.</p>\n<p>Cloud services like AWS, Google Cloud, and Microsoft Azure all support containers in multiple different forms. These include AWS Fargate and Google Cloud Run, both of which run containers as serverless - where the application container does not even need to be running if it is not used. You can also install container runtime on most machines and run containers there yourself - including your own machine. </p>\n<p>So containers are used in clouds and even during development. What are the benefits of using containers? Here are two common scenarios:</p>\n<blockquote>\n<p>Scenario 1: You are developing a new application that needs to run on the same machine as a legacy application. Both require different versions of Node installed.</p>\n</blockquote>\n<p>You can probably use nvm, virtual machines, or dark magic to get them running at the same time. However, containers are an excellent solution as you can run both applications in their respective containers. They are isolated from each other and do not interfere.</p>\n<blockquote>\n<p>Scenario 2: Your application runs on your machine. You need to move the application to a server.</p>\n</blockquote>\n<p>It is not uncommon that the application just does not run on the server despite it working just fine in your machine. It may be due to some missing dependency or other differences in the environments. Here containers are an excellent solution since you can run the application in the same execution environment both on your machine and on the server. It is not perfect: different hardware can be an issue, but you can limit the differences between environments.</p>\n<p>Sometimes you may hear about the <i>\"Works in my container\"</i> issue. The phrase describes a situation in which the application works fine in a container running on your machine but breaks when the container is started on a server. The phrase is a play on the infamous <i>\"Works in my machine\"</i> issue, which containers are often promised to solve. The situation also is most likely a usage error.</p>\n<h3>About this part</h3>\n<p>In this part, the focus of our attention will not be on the JavaScript code. Instead, we are interested in the configuration of the environment in which the software is executed. As a result, the exercises may not contain any coding, the applications are available to you through GitHub and your tasks will include configuring them. The exercises are to be submitted to <i>a single GitHub repository</i> which will include all of the source code and configuration you do during this part.</p>\n<p>You will need basic knowledge of Node, Express, and React. Only the core parts, 1 through 5, are required to be completed before this part.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 12.1</h3>\n<h3><i>Warning</i></h3>\n<p>Since we are stepping right outside of our comfort zone as JavaScript developers, this part may require you to take a detour and familiarize yourself with shell / command line / command prompt / terminal before getting started.</p>\n<p>If you have only ever used a graphical user interface and never touched e.g. Linux or terminal on Mac, or if you get stuck in the first exercises we recommend doing the Part 1 of \"Computing tools for CS studies\" first: <a href=\"https://tkt-lapio.github.io/en/\">https://tkt-lapio.github.io/en/</a>. Skip the section for \"SSH connection\" and Exercise 11. Otherwise, it includes everything you are going to need to get started here!</p>\n<h4>Exercise 12.1: Using a computer (without graphical user interface)</h4>\n<p>Step 1: Read the text below the Warning header.</p>\n<p>Step 2: Download this <a href=\"https://github.com/fullstack-hy2020/part12-containers-applications\">repository</a> and make it your submission repository for this part.</p>\n<p>Step 3: Run <i>curl <a href=\"http://helsinki.fi\">http://helsinki.fi</a></i> and save the output into a file. Save that file into your repository as file <i>script-answers/exercise12_1.txt</i>. The directory <i>script-answers</i> was created in the previous step.</p>\n</div>\n<div class=\"content\">\n<h3>Submitting exercises and earning credits</h3>\n<p>Submit the exercises via the <a href=\"https://studies.cs.helsinki.fi/stats/\">submissions system</a> just like in the previous parts. Exercises in this part are submitted <i>to its <a href=\"https://studies.cs.helsinki.fi/stats/courses/fs-containers\">own course instance</a></i>.</p>\n<p>Completing this part on containers will get you 1 credit. Note that you need to do all the exercises for earning the credit or the certificate.</p>\n<p>Once you have completed the exercises and want to get the credits, let us know through the exercise submission system that you have completed the course:</p>\n<picture><img src=\"/static/ba7a651de70d2d2e13697df135255a90/5a190/23.png\" alt=\"Submitting exercises for credits\" srcset=\"/static/ba7a651de70d2d2e13697df135255a90/772e8/23.png 200w,\n/static/ba7a651de70d2d2e13697df135255a90/e17e5/23.png 400w,\n/static/ba7a651de70d2d2e13697df135255a90/5a190/23.png 800w,\n/static/ba7a651de70d2d2e13697df135255a90/c1b63/23.png 1200w,\n/static/ba7a651de70d2d2e13697df135255a90/29007/23.png 1600w,\n/static/ba7a651de70d2d2e13697df135255a90/50e7d/23.png 1738w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>You can download the certificate for completing this part by clicking one of the flag icons. The flag icon corresponds to the language of the certificate.</p>\n<h3>Tools of the trade</h3>\n<p>The basic tools you are going to need vary between operating systems:</p>\n<ul>\n<li><a href=\"https://docs.microsoft.com/en-us/windows/wsl/install-win10\">WSL 2 terminal</a> on Windows</li>\n<li>Terminal on Mac</li>\n<li>Command Line on a Linux</li>\n</ul>\n<h3>Installing everything required for this part</h3>\n<p>We will begin by installing the required software. The installation step will be one of the possible obstacles. As we are dealing with OS-level virtualization, the tools will require superuser access on the computer. They will have access to your operating systems kernel.</p>\n<p>The material is built around <a href=\"https://www.docker.com/\">Docker</a>, a set of products that we will use for containerization and the management of containers. Unfortunately, if you can not install Docker you probably can not complete this part.</p>\n<p>As the install instructions depend on your operating system, you will have to find the correct install instructions from the link below. Note that they may have multiple different options for your operating system. </p>\n<ul>\n<li><a href=\"https://docs.docker.com/get-docker/\">Get Docker</a></li>\n</ul>\n<p>Now that that headache is hopefully over, let's make sure that our versions match. Yours may have a bit higher numbers than here:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker -v\nDocker version <span class=\"token number\">20.10</span>.5, build 55c4c88</code></pre></div>\n<h3>Containers and images</h3>\n<p>There are two core concepts when starting with containers and they are easy to confuse with one another:</p>\n<p>A <strong>container</strong> is a runtime instance of an <strong>image</strong>.</p>\n<p>Both of the following statements are true:</p>\n<ul>\n<li>Images include all of the code, dependencies and instructions on how to run the application </li>\n<li>Containers package software into standardized units </li>\n</ul>\n<p>It is no wonder they are easily mixed up.</p>\n<p>To help with the confusion, almost everyone uses the word container to describe both. But you can never actually build a container or download one since containers only exist during runtime. Images, on the other hand, are <strong>immutable</strong> files. As a result of the immutability, you can not edit an image after you have created one. However, you can use existing images to create <i>a new image</i> by adding new layers on top of the existing ones.</p>\n<p>Cooking metaphor:</p>\n<ul>\n<li>Image is pre-cooked, frozen treat.</li>\n<li>Container is the delicious treat.</li>\n</ul>\n<p><a href=\"https://www.docker.com/\">Docker</a> is the most popular containerization technology and pioneered the standards most containerization technologies use today. In practice, Docker is a set of products that help us to manage images and containers. This set of products will enable us to leverage all of the benefits of containers. For example, the docker engine will take care of turning the immutable files called images into containers.</p>\n<p>For managing the docker containers, there is also a tool called <a href=\"https://docs.docker.com/compose/\">Docker Compose</a> that allows one to <strong>orchestrate</strong> (control) multiple containers at the same time. In this part we shall use Docker Compose to set up a complex local development environment. In the final version of the development environment that we set up, even installing the Node to our machine is not a requirement anymore.</p>\n<p>There are several concepts we need to go over. But we will skip those for now and learn about Docker first! </p>\n<p>Let us start with the command <i>docker container run</i> that is used to run images within a container. The command structure is the following: <em>container run <i>IMAGE-NAME</i></em> that we will tell Docker to create a container from an image. A particularily nice feature of the command is that it can run a container even if the image to run is not downloaded on our device yet.</p>\n<p>Let us run the command</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">§ docker container run hello-world</code></pre></div>\n<p>There will be a lot of output, but let's split it into multiple sections, which we can decipher together. The lines are numbered by me so that it is easier to follow the explanation. Your output will not have the numbers.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token number\">1</span>. Unable to <span class=\"token function\">find</span> image <span class=\"token string\">'hello-world:latest'</span> locally\n<span class=\"token number\">2</span>. latest: Pulling from library/hello-world\n<span class=\"token number\">3</span>. b8dfde127a29: Pull complete\n<span class=\"token number\">4</span>. Digest: sha256:5122f6204b6a3596e048758cabba3c46b1c937a46b5be6225b835d091b90e46c\n<span class=\"token number\">5</span>. Status: Downloaded newer image <span class=\"token keyword\">for</span> hello-world:latest</code></pre></div>\n<p>Because the image <i>hello-world</i> was not found on our machine, the command first downloaded it from a free registry called <a href=\"https://hub.docker.com/\">Docker Hub</a>. You can see the Docker Hub page of the image with your browser here: <a href=\"https://hub.docker.com/_/hello-world\">https://hub.docker.com/_/hello-world</a></p>\n<p>The first part of the message states that we did not have the image \"hello-world:latest\" yet. This reveals a bit of detail about images themselves; image names consist of multiple parts, kind of like an URL. An image name is in the following format: </p>\n<ul>\n<li><em>registry/organisation/image:tag</em></li>\n</ul>\n<p>In this case the 3 missing fields defaulted to: </p>\n<ul>\n<li><em>index.docker.io/library/hello-world:latest</em></li>\n</ul>\n<p>The second row shows the organisation name, \"library\" where it will get the image. In the Docker Hub url, the \"library\" is shortened to _.</p>\n<p>The 3rd and 5th rows only show the status. But the 4th row may be interesting: each image has a unique digest based on the <i>layers</i> from which the image is built. In practice, each step or command that was used in building the image creates a unique layer. The digest is used by Docker to identify that an image is the same. This is done when you try to pull the same image again.</p>\n<p>So the result of using the command was a pull and then output information about the <strong>image</strong>. After that, the status told us that a new version of hello-world:latest was indeed downloaded. You can try pulling the image with <em>docker image pull hello-world</em> and see what happens.</p>\n<p>The following output was from the container itself. It also explains what happened when we ran <em>docker container run hello-world</em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">Hello from Docker<span class=\"token operator\">!</span>\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n <span class=\"token number\">1</span>. The Docker client contacted the Docker daemon.\n <span class=\"token number\">2</span>. The Docker daemon pulled the <span class=\"token string\">\"hello-world\"</span> image from the Docker Hub.\n    <span class=\"token punctuation\">(</span>amd64<span class=\"token punctuation\">)</span>\n <span class=\"token number\">3</span>. The Docker daemon created a new container from that image <span class=\"token function\">which</span> runs the\n    executable that produces the output you are currently reading.\n <span class=\"token number\">4</span>. The Docker daemon streamed that output to the Docker client, <span class=\"token function\">which</span> sent it\n    to your terminal.\n\nTo try something <span class=\"token function\">more</span> ambitious, you can run an Ubuntu container with:\n $ docker container run -it ubuntu <span class=\"token function\">bash</span>\n\nShare images, automate workflows, and <span class=\"token function\">more</span> with a <span class=\"token function\">free</span> Docker ID:\n https://hub.docker.com/\n\nFor <span class=\"token function\">more</span> examples and ideas, visit:\n https://docs.docker.com/get-started/</code></pre></div>\n<p>The output contains a few new things for us to learn. <i>Docker daemon</i> is a background service that makes sure the containers are running, and we use the <i>Docker client</i> to interact with the daemon. We now have interacted with the first image and created a container from the image. During the execution of that container, we received the output.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 12.2</h3>\n<p>Some of these exercises do not require you to write any code or configurations to a file.\nIn these exercises you should use <a href=\"https://man7.org/linux/man-pages/man1/script.1.html\">script</a> command to record the commands you have used; try it yourself with <em>script</em> to start recording, <em>echo \"hello\"</em> to generate some output, and <em>exit</em> to stop recording. It saves your actions into a file names \"typescript\".</p>\n<p>If <em>script</em> does not work, you can just copy-paste all commands you used into a text file.</p>\n<h4>Exercise 12.2: Running your second container</h4>\n<blockquote>\n<p>Use <em>script</em> to record what you do, save the file as script-answers/exercise12_2.txt</p>\n</blockquote>\n<p>The hello-world output gave us an ambitious task to do. Do the following</p>\n<p>Step 1. Run an Ubuntu container with the command given by hello-world</p>\n<p>The step 1 will connect you straight into the container with bash. You will have access to all of the files and tools inside of the container. The following steps are run within the container:</p>\n<p>Step 2. Create directory <i>/usr/src/app</i></p>\n<p>Step 3. Create a file <i>/usr/src/app/index.js</i></p>\n<p>Step 4. Run <i>exit</i> to quit from the container</p>\n<p>Google should be able to help you with creating directories and files.</p>\n</div>\n<div class=\"content\">\n<h3>Ubuntu image</h3>\n<p>The command you just used to run the ubuntu container, <em>docker container run -it ubuntu bash</em>, contains a few additions to the previously run hello-world. Let's see the --help to get a better understanding. I'll cut some of the output so we can focus on the relevant parts.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container run --help\n\nUsage:  docker container run <span class=\"token punctuation\">[</span>OPTIONS<span class=\"token punctuation\">]</span> IMAGE <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>ARG<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span>\nRun a <span class=\"token builtin class-name\">command</span> <span class=\"token keyword\">in</span> a new container\n\nOptions:\n  <span class=\"token punctuation\">..</span>.\n  -i, --interactive                    Keep STDIN <span class=\"token function\">open</span> even <span class=\"token keyword\">if</span> not attached\n  -t, --tty                            Allocate a pseudo-TTY\n  <span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>The two options, or flags, in <em>-it</em> make sure we can interact with the container. After the options, we defined that image to run is <em>ubuntu</em>. Then we have the command <em>bash</em> to be executed inside the container when we start it.</p>\n<p>You can try other commands that the ubuntu image might be able to execute. As an example try <em>docker container run --rm ubuntu ls</em>. The <em>ls</em> command will list all of the files in the directory and <em>--rm</em> flag will remove the container after execution. Normally containers are not deleted automatically.</p>\n<p>Let's continue with our first ubuntu container with the <strong>index.js</strong> file inside of it. The container has stopped running since we exited it. We can list all of the containers with <em>container ls -a</em>, the <em>-a</em> (or --all) will list containers that have already been exited.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container <span class=\"token function\">ls</span> -a\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                            NAMES\nb8548b9faec3   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">3</span> minutes ago    Exited <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">6</span> seconds ago          hopeful_clarke</code></pre></div>\n<p>We have two options when addressing a container. The identifier in the first column can be used to interact with the container almost always. Plus, most commands accept the container name as a more human-friendly method of working with them. The name of the container was automatically generated to be <strong>\"hopeful_clarke\"</strong> in my case.</p>\n<p>The container has already exited, yet we can start it again with the start command that will accept the id or name of the container as a parameter: <em>start <i>CONTAINER-ID-OR-CONTAINER-NAME</i></em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker start hopeful_clarke\nhopeful_clarke</code></pre></div>\n<p>The start command will start the same container we had previously. Unfortunately, we forgot to start it with the flag <em>--interactive</em> so we can not interact with it.</p>\n<p>The container is actually up and running as the command <em>container ls -a</em> shows, but we just can not communicate it:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container <span class=\"token function\">ls</span> -a\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                            NAMES\nb8548b9faec3   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">7</span> minutes ago    Up <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">15</span> seconds ago            hopeful_clarke</code></pre></div>\n<p>Note that we can also execute the command without the flag <em>-a</em> to see just those containers that are running:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container <span class=\"token function\">ls</span>\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS             NAMES\n8f5abc55242a   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">8</span> minutes ago    Up <span class=\"token number\">1</span> minutes       hopeful_clarke             </code></pre></div>\n<p>Let's kill it with the <em>kill <i>CONTAINER-ID-OR-CONTAINER-NAME</i></em> command and try again. </p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker <span class=\"token function\">kill</span> hopeful_clarke\nhopeful_clarke</code></pre></div>\n<p><em>docker kill</em> sends a <a href=\"https://man7.org/linux/man-pages/man7/signal.7.html\">signal SIGKILL</a> to the process forcing it to exit, and that causes the container to stop. We can check it's status with <em>container ls -a</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container <span class=\"token function\">ls</span> -a\nCONTAINER ID   IMAGE     COMMAND   CREATED             STATUS                     NAMES\nb8548b9faec3   ubuntu     <span class=\"token string\">\"bash\"</span>   <span class=\"token number\">26</span> minutes ago      Exited <span class=\"token number\">2</span> seconds ago       hopeful_clarke</code></pre></div>\n<p>Now let us start the container again, but this time in interactive mode:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker start -i hopeful_clarke\nroot@b8548b9faec3:/<span class=\"token comment\">#</span></code></pre></div>\n<p>Let's edit the file <i>index.js</i> and add in some JavaScript code to execute. We are just missing the tools to edit the file. Nano will be a good text editor for now. The install instructions were found from the first result of Google. We will omit using sudo since we are already root.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@b8548b9faec3:/<span class=\"token comment\"># apt-get update</span>\nroot@b8548b9faec3:/<span class=\"token comment\"># apt-get -y install nano</span>\nroot@b8548b9faec3:/<span class=\"token comment\"># nano /usr/src/app/index.js</span></code></pre></div>\n<p>Now we have nano installed and can start editing files!</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 12.3 - 12.4</h3>\n<h4>Exercise 12.3: Ubuntu 101</h4>\n<blockquote>\n<p>Use <em>script</em> to record what you do, save the file as script-answers/exercise12_3.txt</p>\n</blockquote>\n<p>Edit the <em>/usr/src/app/index.js</em> file inside the container with the now installed nano and add the following line</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello World'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>If you are not familiar with Nano you can ask for help in the chat or Google.</p>\n<h4>Exercise 12.4: Ubuntu 102</h4>\n<blockquote>\n<p>Use <em>script</em> to record what you do, save the file as script-answers/exercise12_4.txt</p>\n</blockquote>\n<p>Install Node while inside the container and run the index file with <em>node /usr/src/app/index.js</em> in the container.</p>\n<p>The instructions for installing Node are sometimes hard to find, so here is something you can copy-paste:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> -sL https://deb.nodesource.com/setup_16.x <span class=\"token operator\">|</span> <span class=\"token function\">bash</span>\n<span class=\"token function\">apt</span> <span class=\"token function\">install</span> -y nodejs</code></pre></div>\n<p>You will need to install the <em>curl</em> into the container. It is installed in the same way as you did with <em>nano</em>.</p>\n<p>After the installation, ensure that you can run your code inside the container with command</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">root@b8548b9faec3:/# node /usr/src/app/index.js\nHello World</code></pre></div>\n</div>\n<div class=\"content\">\n<h3>Other docker commands</h3>\n<p>Now that we have Node installed in the container we can execute JavaScript in the container! Let's create a new image from the container. The <em>commit <i>CONTAINER-ID-OR-CONTAINER-NAME</i> <i>NEW-IMAGE-NAME</i></em> will create a new image that includes the changes we have made. You can use <em>container diff</em> to check for the changes between the original image and container before doing so.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker commit hopeful_clarke hello-node-world</code></pre></div>\n<p>You can list your images with <em>image ls</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker image <span class=\"token function\">ls</span>\nREPOSITORY                                      TAG         IMAGE ID       CREATED         SIZE\nhello-node-world                                latest      eef776183732   <span class=\"token number\">9</span> minutes ago   252MB\nubuntu                                          latest      1318b700e415   <span class=\"token number\">2</span> weeks ago     <span class=\"token number\">72</span>.8MB\nhello-world                                     latest      d1165f221234   <span class=\"token number\">5</span> months ago    <span class=\"token number\">13</span>.3kB</code></pre></div>\n<p>You can now run the new image as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker run -it hello-node-world <span class=\"token function\">bash</span>\nroot@4d1b322e1aff:/<span class=\"token comment\"># node /usr/src/app/index.js</span></code></pre></div>\n<p>There are multiple ways to achieve the same conclusion. Let's go through a better solution. We will clean the slate with <em>container rm</em> to remove the old container.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container <span class=\"token function\">ls</span> -a\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                  NAMES\nb8548b9faec3   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">31</span> minutes ago   Exited <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">9</span> seconds ago               hopeful_clarke\n\n$ docker container <span class=\"token function\">rm</span> hopeful_clarke\nhopeful_clarke</code></pre></div>\n<p>Create a file <i>index.js</i> to your current directory and write <em>console.log('Hello, World')</em> inside it. No need for containers yet.</p>\n<p>Next, let's skip installing Node altogether. There are plenty of useful Docker images in Docker Hub ready for our use. Let's use the image <a href=\"https://hub.docker.com/_/Node\">https://hub.docker.com/_/Node</a>, which has Node already installed. We only need to pick a version.</p>\n<p>By the way, the <em>container run</em> accepts <em>--name</em> flag that we can use to give a name for the container.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container run -it --name hello-node node:16 <span class=\"token function\">bash</span></code></pre></div>\n<p>Let us create a directory for the code inside the container:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">root@77d1023af893:/# mkdir /usr/src/app</code></pre></div>\n<p>While we are inside the container on this terminal, open another terminal and use the <em>container cp</em> command to copy file from your own machine to the container.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container <span class=\"token function\">cp</span> ./index.js hello-node:/usr/src/app/index.js</code></pre></div>\n<p>And now we can run <em>node /usr/src/app/index.js</em> in the container. We can commit this as another new image, but there is an even better solution. The next section will be all about building your images like a pro.</p>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/3c94fa433f40d6b2797b2e0c31a5cba3/part-12.svg"},"part":12,"letter":"a","lang":"en"}}},"pageContext":{"part":12,"letter":"a","lang":"en"}}}